<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【Vue源码学习系列】解读数据响应式实现原理"><meta name="keywords" content="vue,源码学习"><meta name="author" content="Rao Jinwei,undefined"><meta name="copyright" content="Rao Jinwei"><title>【Vue源码学习系列】解读数据响应式实现原理 | Rao Jinwei's Blog</title><link rel="shortcut icon" href="/sl.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.4.2"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读源码前…"><span class="toc-number">2.</span> <span class="toc-text">读源码前…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part1-原理解读"><span class="toc-number">3.</span> <span class="toc-text">Part1: 原理解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#observe"><span class="toc-number">3.1.</span> <span class="toc-text">observe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observer"><span class="toc-number">3.2.</span> <span class="toc-text">Observer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineReactive"><span class="toc-number">3.3.</span> <span class="toc-text">defineReactive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dep"><span class="toc-number">3.4.</span> <span class="toc-text">Dep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher"><span class="toc-number">3.5.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#针对-Array-的处理"><span class="toc-number">3.6.</span> <span class="toc-text">针对 Array 的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part2-实现一个简易的响应式系统"><span class="toc-number">4.</span> <span class="toc-text">Part2: 实现一个简易的响应式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">6.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars1.githubusercontent.com/u/23609695?s=400&amp;u=d2db8f6efdee5add420addf7f89b916f7ef47ca7&amp;v=4"></div><div class="author-info__name text-center">Rao Jinwei</div><div class="author-info__description text-center">追寻生活的影子</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pic1.win4000.com/wallpaper/7/59bb35a6c903f.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rao Jinwei's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">【Vue源码学习系列】解读数据响应式实现原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/vue源码/">vue源码</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用<code>vue</code>开发有一段时间了，我觉得是时候去深入学习其内部的实现原理了。写过<code>vue</code>的童鞋都知道，响应式系统是其最有意思、最独特的特征之一，这个特征可以让我们摆脱了频繁对<code>dom</code>的操作，得以让我们更专注于数据层面，因为在<code>vue</code>面前，数据和视图是双向绑定的，也就是所谓的数据驱动视图、<code>mvvm</code>模型。该文章是vue源码学习系列的第一篇，源码是基于<code>2.6.10</code>版本。</p>
<a id="more"></a>
<h2 id="读源码前…"><a href="#读源码前…" class="headerlink" title="读源码前…"></a>读源码前…</h2><p>关于这个原理，我之前是一直停留于<code>Object.defineProperty</code>这个概念中，知道<code>vue</code>是通过在<code>getter</code>中进行依赖的收集，<code>setter</code>中触发视图层的更新。虽然之前有看过一些源码解读的文章，能大概看懂一些，但毕竟还是没有去读过源码，所以对于这部分的很多细节上的处理是比较模糊的。于是决定通过源码去一步步去了解、学习其幕后的操作是什么。非常感谢，<code>vue</code>是开源的，任何细节都可以在源码中找到答案。</p>
<p>全文分为两个部分，第一部分为<strong>从源码中进行原理解读</strong>，第二部分为<strong>从0开始实现一个简洁的响应式系统</strong>。</p>
<h2 id="Part1-原理解读"><a href="#Part1-原理解读" class="headerlink" title="Part1: 原理解读"></a>Part1: 原理解读</h2><p>先来一张官方提供的原理图：</p>
<p><img src="https://cn.vuejs.org/images/data.png" alt="官方原理图"></p>
<p>从图中可以看出，<code>render</code>函数会触发<code>getter</code>在<code>Watcher</code>对象中进行<code>Collect as Dependency</code>(收集依赖)，然后在<code>setter</code>中通知<code>Watcher</code>进行视图层的更新。这个架构图中，可以看出其响应式原理实际上是用了<strong>观察者模式</strong>，观察者模式是一种一对多的依赖关系，当某个<strong>被监听</strong>的对象更新时，所有监听它的对象都会<strong>收到通知</strong>，然后触发相关事件等等。用类比的方式，可以这么说，<code>github</code>上的每个用户都是<code>Watcher</code>，用户间可以互相<code>follow</code>，如果被<code>follow</code>的用户<code>star</code>了某个项目或者<code>created</code>了新项目，<code>followers</code>则会主页上看到他们的动态。这张图只是<code>vue</code>响应式思想的精华，但是还是有很多细节需要去学习和掌握的。</p>
<p>来一张我在读源码过程中，边读边画边改的流程图：</p>
<p><img src="https://img-1257816861.cos.ap-guangzhou.myqcloud.com/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%861.png" alt="vue响应式原理"></p>
<p>这张图可以说很具体的描述了响应式系统工作流程。在画的过程中，通过打断点和写demo，不断地去验证和修改里面的细节，花了我不少精力。但是整体下来，也让我对整个响应式的过程有了更清晰的了解，终于不是停留在<code>Object.defineProperty</code>层面上了。<code>Object.defineProperty</code>虽说确实是基础，但是如果只知道这个<code>api</code>是远远不足以掌握<code>vue</code>响应式原理，况且<code>vue3.0</code>也将用<code>Proxy</code>取代<code>Object.defineProperty</code>。</p>
<h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><blockquote>
<p>响应式源码位于<code>src/core/observer</code></p>
</blockquote>
<p>在开发中，打印在vue<code>data</code>选项注册的对象时常可以看到附带着<code>__ob__</code>这个属性，只知道携带了这个属性的对象就是<strong>响应式</strong>的，比如这种：</p>
<p><img src="https://img-1257816861.cos.ap-guangzhou.myqcloud.com/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%862.png" alt="__ob__"></p>
<p>那么，这个属性具体是如何注册进去的，又有何用呢？</p>
<p>在我画的流程图可以看出，<code>observe</code>是响应式的入口，这里逻辑主要是给对象实例化一个<code>Observer</code>，也就是上图中响应式对象携带的<code>__ob__</code>属性，我把源码贴出来看看，通过注释来进行解读：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></div><div class="line"><span class="comment"> * returns the new observer if successfully observed,</span></div><div class="line"><span class="comment"> * or the existing observer if the value already has one.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="comment">// 注意，这里 isObject 包括对象和数组</span></div><div class="line">  <span class="comment">// 也就是过滤掉基本类型和 VNode 的实例</span></div><div class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></div><div class="line">  <span class="comment">// 防止重复实例化 Observer</span></div><div class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</div><div class="line">    ob = value.__ob__</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</div><div class="line">    <span class="comment">// 这里判断暂且忽略</span></div><div class="line">    shouldObserve &amp;&amp;</div><div class="line">    !isServerRendering() &amp;&amp;</div><div class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</div><div class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</div><div class="line">    !value._isVue</div><div class="line">  ) &#123;</div><div class="line">    <span class="comment">// 给该对象弄个 Observer</span></div><div class="line">    ob = <span class="keyword">new</span> Observer(value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</div><div class="line">    ob.vmCount++</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ob</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的逻辑其实还是比较简单的，通过上面尤大的英文注释也可以看到这块函数的作用。接下来一起看看<code>Observer</code>具体内容。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p><code>Observer</code>是一个类，这个类有2个很重要的方法，分别是<code>walk</code>和<code>observeArray</code>，分别是对对象和数组的进行响应式绑定，来看看实际源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">constructor</span> (value: any) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep() <span class="comment">// 用于收集该响应式对象的依赖</span></div><div class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></div><div class="line">    <span class="comment">// 使用 Object.defineProperty 定义 __ob__ 属性</span></div><div class="line">    <span class="comment">// 这也就是上文提到的为什么控制台打印响应式对象拥有 __ob__ 这个属性</span></div><div class="line">    <span class="comment">// 注意 __ob__ 是不可枚举的</span></div><div class="line">    <span class="comment">// Vue.set 方法需要用到这个属性</span></div><div class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">      <span class="comment">// hasProto =&gt; `__proto__` in &#123;&#125;</span></div><div class="line">      <span class="keyword">if</span> (hasProto) &#123;</div><div class="line">        <span class="comment">// 针对数组实现响应式的方法</span></div><div class="line">        protoAugment(value, arrayMethods)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        copyAugment(value, arrayMethods, arrayKeys)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.observeArray(value)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 对象走这套</span></div><div class="line">      <span class="keyword">this</span>.walk(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Walk through all properties and convert them into</span></div><div class="line"><span class="comment">   * getter/setters. This method should only be called when</span></div><div class="line"><span class="comment">   * value type is Object.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</div><div class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">      <span class="comment">// 给对象每个 key 进行响应式绑定，重写 getter/setter 方法</span></div><div class="line">      defineReactive(obj, keys[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Observe a list of Array items.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</div><div class="line">      <span class="comment">// 给数组每个值进行响应式绑定</span></div><div class="line">      <span class="comment">// 如果值是对象、数组会递归绑定</span></div><div class="line">      observe(items[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完上面<code>Observer</code>的实现，其最主要的目的就是给对象和数组递归进行响应式绑定，只不过<strong>这2者的绑定方式有区别的</strong>，数组是绑定原理下文会去说，让我们先来看看给对象<code>key</code>进行响应式绑定的<code>defineReactive</code>方法做了哪些事情。</p>
<h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><p><code>defineReactive</code>其实就是使用<code>Object.defineProperty</code>的地方了，所以说这里会有收集依赖和通知更新的相关逻辑，除了这些，还有一些小细节非常值得我们学习，一起来看看源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Define a reactive property on an Object.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  obj: Object,</span></span></div><div class="line"><span class="function"><span class="params">  key: string,</span></span></div><div class="line"><span class="function"><span class="params">  val: any,</span></span></div><div class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></div><div class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 用于收集当前对象某个key的依赖</span></div><div class="line">  <span class="comment">// 利用闭包，巧妙地实现了每个 key 都拥有了其各自 dep 实例</span></div><div class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</div><div class="line"></div><div class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</div><div class="line">  <span class="comment">// 这里会判断该属性是否可以被改写 property ，比如被 Object.freeze() 之后的属性就无法修改</span></div><div class="line">  <span class="comment">// 所以不想被 vue 重写 getter/setter 的属性可以用 property.configurable = false</span></div><div class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// cater for pre-defined getter/setters</span></div><div class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</div><div class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</div><div class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</div><div class="line">    val = obj[key]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 对每个value都跑一次observe，递归入口</span></div><div class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    <span class="comment">// 重写 data 每个 key 的 getter 函数</span></div><div class="line">    <span class="comment">// 先绑定，记住当前的 dep、childOb</span></div><div class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</div><div class="line">      <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">        <span class="comment">// 收集依赖</span></div><div class="line">        dep.depend()</div><div class="line">        <span class="comment">// 利用闭包，如果当前对象存在 childOb，通知其收集依赖</span></div><div class="line">        <span class="keyword">if</span> (childOb) &#123;</div><div class="line">          childOb.dep.depend()</div><div class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            <span class="comment">// 收集数组的依赖</span></div><div class="line">            dependArray(value)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 重写data每个key的 setter 函数</span></div><div class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</div><div class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></div><div class="line"></div><div class="line">      <span class="comment">// 新旧值一样就不做处理</span></div><div class="line">      <span class="comment">// (newVal !== newVal &amp;&amp; value !== value) 是处理 NaN</span></div><div class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</div><div class="line">        customSetter()</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// #7981: for accessor properties without setter</span></div><div class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></div><div class="line">      <span class="keyword">if</span> (setter) &#123;</div><div class="line">        setter.call(obj, newVal)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        val = newVal</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 赋予一个新值时，再次全部执行 observe</span></div><div class="line">      childOb = !shallow &amp;&amp; observe(newVal)</div><div class="line">      <span class="comment">// 通知 Watcher 更新</span></div><div class="line">      dep.notify()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这块是响应式对象绑定核心实现的地方，该处出现了<code>dep</code>相关逻辑，分别用于依赖收集和通知更新。每个属性都有其各自的<code>dep</code>实例，这里很巧妙地利用了闭包实现了记住作用域的<code>dep</code>引用。还有一个地方，如果对象的<code>property.configurable</code>为<code>false</code>，则不会被包装成响应式对象，正如<code>vue</code>文档上说可以用<code>Object.freeze</code>进行相关优化。在这里我们可以看到<code>dep</code>实例有着非常重要的作用，在官方的流程图中并未出现关于<code>dep</code>的解析，让我们一起来结合源码看看<code>dep</code>到时做了什么，是如何收集依赖和派发通知的。</p>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p><code>Dep</code>可以理解成可以被<code>Watcher</code>观察的对象，也可以说是<strong>订阅者</strong>。上文说了每个属性对象都有其各自的<code>dep</code>实例，这些实例都是可以被观察的，那么既然可以被观察，它<strong>就要知道有多少位观察者(Watcher)</strong>，所以这里必须要有收集和存储这些观察者的地方，也就是所谓的<strong>依赖收集地</strong>。上文有说到<code>setter</code>会执行<code>dep.notify()</code>方法，所以<code>dep</code>除了有收集依赖，还有向这些依赖发送消息的作用。</p>
<p>来看下源码部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A dep is an observable that can have multiple</span></div><div class="line"><span class="comment"> * directives subscribing to it.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> target: ?Watcher; <span class="comment">// 核心，指向当前 Watcher</span></div><div class="line">  id: number;</div><div class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.id = uid++</div><div class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 依赖收集池</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 收集依赖</span></div><div class="line">  addSub (sub: Watcher) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 移除依赖</span></div><div class="line">  removeSub (sub: Watcher) &#123;</div><div class="line">    remove(<span class="keyword">this</span>.subs, sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// `getter` 中出现的 dep.depend</span></div><div class="line">  depend () &#123;</div><div class="line">    <span class="comment">// 如果当前有存在的 Watcher，就添加依赖</span></div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      <span class="comment">// 这里很巧妙，Watcher.addDep 实际上是调用 this.addSub 方法</span></div><div class="line">      <span class="comment">// 也就是通过依赖关系把 Watcher 存到了当前 `dep` 实例中</span></div><div class="line">      Dep.target.addDep(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 消息通知</span></div><div class="line">  notify () &#123;</div><div class="line">    <span class="comment">// stabilize the subscriber list first</span></div><div class="line">    <span class="comment">// 拷贝一份依赖池，不影响原有的数据</span></div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</div><div class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></div><div class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></div><div class="line">      <span class="comment">// order</span></div><div class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      <span class="comment">// 按注册顺序派发消息</span></div><div class="line">      subs[i].update()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// The current target watcher being evaluated.</span></div><div class="line"><span class="comment">// This is globally unique because only one watcher</span></div><div class="line"><span class="comment">// can be evaluated at a time.</span></div><div class="line"><span class="comment">// 用于指向当前 Watcher</span></div><div class="line"><span class="comment">// 同一时间只有一个 Watcher</span></div><div class="line">Dep.target = <span class="literal">null</span></div><div class="line"><span class="keyword">const</span> targetStack = []</div><div class="line"></div><div class="line"><span class="comment">// 给 target 赋值给指定的 Watcher</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123;</div><div class="line">  targetStack.push(target)</div><div class="line">  Dep.target = target</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除最后一个 Watcher</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  targetStack.pop()</div><div class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>Dep</code>其实扮演着对<code>Watcher</code>管理的一种角色。所以说<code>Dep</code>是响应式系统中不可或缺的一环。同样的，<code>Watcher</code>也是非常重要了，脱离<code>Watcher</code>的<code>Dep</code>将没有任何意义，下面来看看<code>Watcher</code>的源码实现。</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></div><div class="line"><span class="comment"> * and fires callback when the expression value changes.</span></div><div class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  vm: Component;</div><div class="line">  expression: string;</div><div class="line">  cb: <span class="built_in">Function</span>; <span class="comment">// 回调</span></div><div class="line">  id: number;</div><div class="line">  deep: boolean;</div><div class="line">  user: boolean; <span class="comment">// user watcher 用户定义的 watcher</span></div><div class="line">  lazy: boolean; <span class="comment">// computed watcher computed 选项</span></div><div class="line">  sync: boolean;</div><div class="line">  dirty: boolean;</div><div class="line">  active: boolean;</div><div class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;; <span class="comment">// 观察者池</span></div><div class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</div><div class="line">  depIds: SimpleSet;</div><div class="line">  newDepIds: SimpleSet;</div><div class="line">  before: ?<span class="built_in">Function</span>;</div><div class="line">  getter: <span class="built_in">Function</span>;</div><div class="line">  value: any;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component,</div><div class="line">    expOrFn: string | Function, // 函数表达式或者方法</div><div class="line">    cb: Function, // 回调</div><div class="line">    options?: ?Object,</div><div class="line">    isRenderWatcher?: boolean</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm</div><div class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</div><div class="line">      vm._watcher = <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    vm._watchers.push(<span class="keyword">this</span>)</div><div class="line">    <span class="comment">// options</span></div><div class="line">    <span class="keyword">if</span> (options) &#123;</div><div class="line">      <span class="keyword">this</span>.deep = !!options.deep</div><div class="line">      <span class="keyword">this</span>.user = !!options.user</div><div class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</div><div class="line">      <span class="keyword">this</span>.sync = !!options.sync</div><div class="line">      <span class="keyword">this</span>.before = options.before</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.cb = cb</div><div class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></div><div class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></div><div class="line">    <span class="comment">// 这里 新旧dep 比对主要用于优化</span></div><div class="line">    <span class="keyword">this</span>.deps = []</div><div class="line">    <span class="keyword">this</span>.newDeps = []</div><div class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></div><div class="line">      <span class="comment">// 便于调试</span></div><div class="line">      ? expOrFn.toString()</div><div class="line">      : <span class="string">''</span></div><div class="line">    <span class="comment">// parse expression for getter</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.getter = expOrFn</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</div><div class="line">        <span class="keyword">this</span>.getter = noop</div><div class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</div><div class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</div><div class="line">          <span class="string">'For full control, use a function instead.'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// computed 是惰性的，在 evaluate 方法才会去计算取值</span></div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</div><div class="line">      ? <span class="literal">undefined</span></div><div class="line">      : <span class="keyword">this</span>.get()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  get () &#123;</div><div class="line">    pushTarget(<span class="keyword">this</span>) <span class="comment">// 就上文说的让 Dep.target 指向当前实例</span></div><div class="line">    <span class="keyword">let</span> value</div><div class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 这里就是触发 `getter` 的地方，进行依赖收集</span></div><div class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</div><div class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> e</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></div><div class="line">      <span class="comment">// dependencies for deep watching</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</div><div class="line">        <span class="comment">// 深度收集依赖</span></div><div class="line">        traverse(value)</div><div class="line">      &#125;</div><div class="line">      popTarget() <span class="comment">// 清除 Dep.target 当前指向，避免反复收集</span></div><div class="line">      <span class="keyword">this</span>.cleanupDeps()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Add a dependency to this directive.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="comment">// 添加订阅者</span></div><div class="line">  addDep (dep: Dep) &#123;</div><div class="line">    <span class="keyword">const</span> id = dep.id</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</div><div class="line">      <span class="keyword">this</span>.newDepIds.add(id)</div><div class="line">      <span class="keyword">this</span>.newDeps.push(dep)</div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</div><div class="line">        <span class="comment">// 上文有说到，watcher.addDep 最终就是调 dep.addSub</span></div><div class="line">        dep.addSub(<span class="keyword">this</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Clean up for dependency collection.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="comment">// 清除依赖相关逻辑</span></div><div class="line">  cleanupDeps () &#123;</div><div class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</div><div class="line">        dep.removeSub(<span class="keyword">this</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</div><div class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</div><div class="line">    <span class="keyword">this</span>.newDepIds = tmp</div><div class="line">    <span class="keyword">this</span>.newDepIds.clear()</div><div class="line">    tmp = <span class="keyword">this</span>.deps</div><div class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</div><div class="line">    <span class="keyword">this</span>.newDeps = tmp</div><div class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Subscriber interface.</span></div><div class="line"><span class="comment">   * Will be called when a dependency changes.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  update () &#123;</div><div class="line">    <span class="comment">/* istanbul ignore else */</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</div><div class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</div><div class="line">      <span class="comment">// 同步的话，直接执行</span></div><div class="line">      <span class="keyword">this</span>.run()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 异步推入更新队列中</span></div><div class="line">      queueWatcher(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Scheduler job interface.</span></div><div class="line"><span class="comment">   * Will be called by the scheduler.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="comment">// 执行 callback</span></div><div class="line">  run () &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</div><div class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</div><div class="line">      <span class="keyword">if</span> (</div><div class="line">        <span class="comment">// 这里有个优化，会有新老值的对比，如果不变就不会重新执行相关回调，比如 render 函数</span></div><div class="line">        value !== <span class="keyword">this</span>.value ||</div><div class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></div><div class="line">        <span class="comment">// when the value is the same, because the value may</span></div><div class="line">        <span class="comment">// have mutated.</span></div><div class="line">        isObject(value) ||</div><div class="line">        <span class="keyword">this</span>.deep</div><div class="line">      ) &#123;</div><div class="line">        <span class="comment">// set new value</span></div><div class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</div><div class="line">        <span class="keyword">this</span>.value = value</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 属性</span></div><div class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Evaluate the value of the watcher.</span></div><div class="line"><span class="comment">   * This only gets called for lazy watchers.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  evaluate () &#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  depend () &#123;</div><div class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">      <span class="keyword">this</span>.deps[i].depend()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Remove self from all dependencies' subscriber list.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  teardown () &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</div><div class="line">      <span class="comment">// remove self from vm's watcher list</span></div><div class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></div><div class="line">      <span class="comment">// if the vm is being destroyed.</span></div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</div><div class="line">        remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</div><div class="line">      <span class="keyword">while</span> (i--) &#123;</div><div class="line">        <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.active = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Watcher</code>的源码较上面几个模块比起来，代码稍微复杂了些，其实里面包含了对vue的<code>computed</code>和<code>watch</code>选项的相关逻辑，关于这块的实现原理，我会另开一篇文章详细解析，最近还在研究中，所以就暂不详细解读计算属性和侦听属性相关逻辑了。主要是其对<code>Dep</code>有联系的地方进行解读。关于上面的部分，可以精简为下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(vm, fn) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm</div><div class="line">    Dep.target = <span class="keyword">this</span></div><div class="line">    <span class="keyword">this</span>.value = fn()</div><div class="line">    <span class="keyword">this</span>.cb = fn</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addDep(dep) &#123;</div><div class="line">    dep.addSub(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update() &#123;</div><div class="line">    <span class="keyword">this</span>.cb(); <span class="comment">// vm.render</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，其实最核心的地方就是<strong>Dep.target的指向</strong>、<strong>收集当前Watcher</strong>和<strong>触发相关回调</strong>。我们联系上文提到的<code>dep.addSub</code>方法，其实最终目的就是把<strong>当前的观察者收入到触发了<code>getter</code>的属性闭包<code>dep</code>实例中</strong>，然后在<code>setter</code>中触发<code>update</code>方法，最终进行相关视图的更新。</p>
<p>那么，在什么时候会实例化<code>Watcher</code>呢？</p>
<p><code>Watcher</code>有视图<code>render watcher</code>、<code>user watcher</code>和<code>computed watcher</code>这三种。<code>render watcher</code>会在Vue<code>mount</code>的时候进行<code>new Watcher</code>。你可能会问，为什么要在<code>mount</code>时候实例化？其实这是一种优化。当触发<code>mount</code>了，就会调用编译好的<code>render</code>函数，<strong><code>render</code>函数会对响应式对象的值进行访问，也就是会触发<code>getter</code>函数</strong>，所以这些属性值的<code>dep</code>实例就会把当前<code>watcher</code>收集起来。<strong>所谓的优化，就是只有视图层(template || render)有用到的值，才会把当前<code>watcher</code>实例<code>push</code>到对应的<code>dep</code>实例中，触发了<code>setter</code>才会进行<code>vm.render</code>视图更新</strong>。定义了值了的视图层没引用的，即使值变了触发<code>setter</code>，也不会走<code>vm.render</code>，因为<code>watcher</code>没被收集进去。</p>
<p>所以，我试着验证了下，在模板层引用了应用了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line"> &#123;&#123;value&#125;&#125;</div><div class="line"> &#123;&#123;computedValue&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript"> <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></div><div class="line"><span class="undefined">   data: &#123;</span></div><div class="line"><span class="undefined">     value: 123</span></div><div class="line"><span class="undefined">   &#125;,</span></div><div class="line"><span class="undefined">   computed: &#123;</span></div><div class="line"><span class="undefined">     computedValue() &#123;</span></div><div class="line"><span class="javascript">       <span class="keyword">return</span> <span class="keyword">this</span>.value + <span class="number">1</span></span></div><div class="line"><span class="undefined">     &#125;</span></div><div class="line"><span class="undefined">   &#125;,</span></div><div class="line"><span class="undefined"> &#125;)</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="https://img-1257816861.cos.ap-guangzhou.myqcloud.com/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%863.png" alt="watcher"></p>
<p>在源码处，我打了个log看看<code>value</code>的<code>dep</code>实例收集到的<code>watcher</code>，我们可以看到，图中<code>dep</code>实例收集到了2个<code>watcher</code>，分别是<code>render watcher</code>和<code>computed watcher</code>，<code>expression</code>可以看到对应的回调，不过只有在非生产环境有效，主要是方便我们去调试。在图中框中的地方还可以看到<code>computed</code>属性的函数表达式，为什么<code>computed</code>可以缓存？可以通过这些联系到，只有当<code>computed</code>里面的依赖(属性)被改变并且触发了<code>setter</code>，这时该依赖属性的<code>dep</code>才会触发<code>notify</code>方法进行消息发布，通知这个<code>computed watcher</code>执行这个函数表达式，如果视图<code>render watcher</code>被收集进去了，这样最后视图层就会触发<code>re-render</code>。</p>
<p><code>Dep</code>和<code>Watcher</code>是观察者模式经典实现，依赖的收集和消息的发布都交给<code>Dep</code>，<code>Watcher</code>则负责了触发视图更新和相关的自定义回调事件。</p>
<h3 id="针对-Array-的处理"><a href="#针对-Array-的处理" class="headerlink" title="针对 Array 的处理"></a>针对 Array 的处理</h3><p>上文有个空缺的地方还没有补上，就是数组是如何做到响应式的？<code>Object.defineProperty</code>只能对对象进行响应式绑定，对数组是无法绑定的。<code>vue</code>内部先用一个对象原型去继承数组这些原生方法，再去给该对象定义数组的方法对应的<code>key</code>，当访问这些<code>key</code>时会触发<code>getter</code>劫持监听，这样就做到了<code>push</code>或者<code>pop</code>等方法时视图也进行相关更新。</p>
<p>可能这样干讲会有点难理解，还是结合源码来看看：</p>
<p>还记得上面<code>Observer</code>类中有这些相关逻辑吗：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">  <span class="comment">// hasProto =&gt; `__proto__` in &#123;&#125;</span></div><div class="line">    <span class="keyword">if</span> (hasProto) &#123;</div><div class="line">      <span class="comment">// 针对数组实现响应式的方法</span></div><div class="line">      protoAugment(value, arrayMethods)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里有个<code>protoAugment</code>方法，看看里面是什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Augment a target Object or Array by intercepting</span></div><div class="line"><span class="comment"> * the prototype chain using __proto__</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object</span>) </span>&#123;</div><div class="line">  target.__proto__ = src</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来是通过改变<code>__proto__</code>的值来改变<code>target</code>的原型，我们可以在看到，当<code>value</code>值为<code>array</code>时，会把该值的原型指向<code>arrayMethods</code>，那么<code>arrayMethods</code>又是什么呢？</p>
<p>源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</div><div class="line"><span class="comment">// arrayMethods.__proto__ = arrayProto</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</div></pre></td></tr></table></figure>
<p>原来<code>arrayMethods</code>是通过<code>Object.create</code>方法实现对<code>Array</code>原型方法的继承，也就是说<code>arrayMethods</code>的原型对象是<code>arrayProto</code>，所有<code>Array</code>的方法<code>arrayMethods</code>都可以访问。</p>
<p>下面来看看<code>key</code>的绑定和劫持：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只劫持一下这几种方法</span></div><div class="line"><span class="keyword">const</span> methodsToPatch = [</div><div class="line">  <span class="string">'push'</span>,</div><div class="line">  <span class="string">'pop'</span>,</div><div class="line">  <span class="string">'shift'</span>,</div><div class="line">  <span class="string">'unshift'</span>,</div><div class="line">  <span class="string">'splice'</span>,</div><div class="line">  <span class="string">'sort'</span>,</div><div class="line">  <span class="string">'reverse'</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Intercept mutating methods and emit events</span></div><div class="line"><span class="comment"> */</span></div><div class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</div><div class="line">  <span class="comment">// 闭包缓存当前的方法</span></div><div class="line">  <span class="keyword">const</span> original = arrayProto[method]</div><div class="line">  <span class="comment">// def 其实是 Object.defineProperty 的封装</span></div><div class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="comment">// 执行拿到结果</span></div><div class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</div><div class="line">    <span class="comment">// 拿到 Observer 实例</span></div><div class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</div><div class="line">    <span class="keyword">let</span> inserted</div><div class="line">    <span class="keyword">switch</span> (method) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</div><div class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</div><div class="line">        inserted = args</div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</div><div class="line">        inserted = args.slice(<span class="number">2</span>)</div><div class="line">        <span class="keyword">break</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对于增加数组长度、有新值插入或者更改，都要走一遍`observe`方法</span></div><div class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</div><div class="line">    <span class="comment">// 通过 dep 发布消息</span></div><div class="line">    ob.dep.notify()</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>所以，通过源码，我们可以知道了为什么<code>vue</code>无法检测数组某个索引值的改动或者直接修改数组的长度了，<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="external">文档参考</a></p>
<p>到这里，<code>vue</code>响应式相关原理已经讲解完毕，结合上面的流程图和源码，再回顾一下，希望能帮助你理解其中的原理知识。<code>vue</code>的源码实现真的非常精妙，我们可以在里面学习到非常多的知识。</p>
<h2 id="Part2-实现一个简易的响应式系统"><a href="#Part2-实现一个简易的响应式系统" class="headerlink" title="Part2: 实现一个简易的响应式系统"></a>Part2: 实现一个简易的响应式系统</h2><p>有了上面源码基础，再结合自己的理解，我们可以试着从0开始实现一个简易的响应式系统</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 数组响应式相关实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src</span>) </span>&#123;</div><div class="line">  target.__proto__ = src</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</div><div class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</div><div class="line"></div><div class="line"><span class="keyword">const</span> methods = [</div><div class="line">  <span class="string">'push'</span>, <span class="string">'pop'</span>, <span class="string">'shift'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>, <span class="string">'sort'</span>, <span class="string">'reverse'</span></div><div class="line">];</div><div class="line"></div><div class="line">methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</div><div class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> original = arrayProto[method];</div><div class="line">      <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'触发 array methods'</span>);</div><div class="line">      <span class="keyword">return</span> result</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(value) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</div><div class="line">    <span class="built_in">Object</span>.defineProperty(value, <span class="string">'__ob__'</span>, &#123;</div><div class="line">      value: <span class="keyword">this</span>,</div><div class="line">      configurable: <span class="literal">true</span>,</div><div class="line">      writable: <span class="literal">true</span>,</div><div class="line">      enumerable: <span class="literal">false</span></div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">      protoAugment(value, arrayMethods);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.walk(value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  walk(obj) &#123;</div><div class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</div><div class="line">    keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> defineReactive(obj, key));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  observeArray(items) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</div><div class="line">      observe(items[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> ob</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</div><div class="line">    ob = value.__ob__</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    ob = <span class="keyword">new</span> Observer(value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ob;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 绑定响应式对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 把 dep 实例存在当前的闭包里，每个属性都有其对应的 dep 实例</span></div><div class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</div><div class="line"></div><div class="line">  val = obj[key];</div><div class="line">  <span class="comment">// 递归</span></div><div class="line">  <span class="keyword">let</span> childOb = observe(val);</div><div class="line"></div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'get'</span>);</div><div class="line">      <span class="comment">// 收集当前属性与 Watcher 中的依赖关系</span></div><div class="line">      dep.depend();</div><div class="line">      <span class="keyword">if</span> (childOb) &#123;</div><div class="line">        childOb.dep.depend();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> val;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'set'</span>);</div><div class="line">      <span class="keyword">if</span> (newVal === val) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      val = newVal;</div><div class="line">      dep.notify(); <span class="comment">// 通知更新</span></div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> depId = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.id = depId++;</div><div class="line">    <span class="keyword">this</span>.subs = [];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  depend() &#123;</div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      Dep.target.addDep(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addSub(watcher) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(watcher)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 发布</span></div><div class="line">  notify() &#123;</div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</div><div class="line">    subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.update())</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 观察者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(vm, fn) &#123;</div><div class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// target指向自己</span></div><div class="line">    <span class="keyword">this</span>.value = fn() <span class="comment">// `render` 触发 `getter`，然后通知 `dep` 收集依赖</span></div><div class="line">    <span class="keyword">this</span>.cb = fn</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addDep(dep) &#123;</div><div class="line">    dep.addSub(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update() &#123;</div><div class="line">    <span class="keyword">this</span>.cb();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options) &#123;</div><div class="line">    <span class="keyword">if</span> (options &amp;&amp; options.data) &#123;</div><div class="line">      <span class="keyword">this</span>.data = options.data</div><div class="line">    &#125;</div><div class="line">    observe(<span class="keyword">this</span>.data);</div><div class="line">    <span class="comment">// render watcher</span></div><div class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, <span class="keyword">this</span>.render.bind(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">this</span>.data.value; <span class="comment">// getter</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> data = &#123;</div><div class="line">  value: <span class="number">123</span>,</div><div class="line">  obj: &#123;</div><div class="line">    foo: &#123;</div><div class="line">      name: <span class="string">'foo'</span>,</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">  text: <span class="string">'hello'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  data</div><div class="line">&#125;);</div><div class="line"></div><div class="line">vm.data.value; <span class="comment">// get</span></div><div class="line">vm.data.value = <span class="number">666</span>; <span class="comment">// set &amp;&amp; update</span></div></pre></td></tr></table></figure>
<p>一个简洁的<code>vue</code>响应式系统其实不用很多的代码就能做出来，这都归功于<code>vue</code>数据驱动的思想和优雅的设计。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结下，关于响应式原理，最基本的还是上文最开始提到的通过<code>Object.defineProperty</code>这个api去进行构造响应式对象，重写<code>set</code>和<code>get</code>方法，并给每个<code>key</code>附带一个<code>dep</code>订阅者，在<code>get</code>函数中订阅<code>Watcher</code>，在<code>set</code>函数中向所有收集到的<code>Watcher</code>发布消息，最后更新视图。</p>
<p>通过这次源码阅读和学习，收获颇多。源码阅读算是跟大神近距离交流的一种方式吧，从中可以学习到作者的设计意图和思想。源码学习是非常具有挑战性的，不是说看了一遍就能理解，很多地方的逻辑不会写得很直观，需要反复看，反复嚼，还需要借鉴一些好的资料才能理解。对源码吃得越透，会很好地辅助平常的开发，对问题、bug的定位也会更加迅速。</p>
<p>如果文中存在不足之处，希望大家可以指出，一起进步。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank" rel="external">Vue.js 技术揭秘</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/61915640" target="_blank" rel="external">【2019 前端进阶之路】深入 Vue 响应式原理，活捉一个 MVVM</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rao Jinwei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://shooterblog.site/2019/07/09/【Vue源码学习系列】解读数据响应式实现原理/">http://shooterblog.site/2019/07/09/【Vue源码学习系列】解读数据响应式实现原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明来自 <a href="http://shooterblog.site" target="_blank">Rao Jinwei's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/源码学习/">源码学习</a></div><elif theme.sharejs && theme.sharejs.enable></elif></article><nav id="pagination"><div class="next-post pull-right"><a href="/2019/05/25/GraphQL + Apollo + Vue 牛刀小试/"><span>GraphQL + Apollo + Vue 牛刀小试</span><i class="fa fa-chevron-right"></i></a></div></nav><elif theme.laibili && theme.laibili.enable></elif><elif theme.gitment && theme.gitment.enable></elif><elif theme.gitalk && theme.gitalk.enable></elif></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Rao Jinwei</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.4.2"></script><script src="/js/fancybox.js?version=1.4.2"></script><script src="/js/sidebar.js?version=1.4.2"></script><script src="/js/copy.js?version=1.4.2"></script><script src="/js/fireworks.js?version=1.4.2"></script><script src="/js/transition.js?version=1.4.2"></script><script src="/js/scroll.js?version=1.4.2"></script><script src="/js/head.js?version=1.4.2"></script></body></html>