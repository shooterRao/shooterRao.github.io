<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="运用react-navigation重构项目总结"><meta name="keywords" content="重构,react"><meta name="author" content="Rao Jinwei,undefined"><meta name="copyright" content="Rao Jinwei"><title>运用react-navigation重构项目总结 | Rao Jinwei's Blog</title><link rel="shortcut icon" href="/sl.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.4.2"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Question：为什么要重构？"><span class="toc-number">2.</span> <span class="toc-text">Question：为什么要重构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重构前的准备"><span class="toc-number">3.</span> <span class="toc-text">重构前的准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开始重构"><span class="toc-number">4.</span> <span class="toc-text">开始重构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于页面跳转的实现"><span class="toc-number">4.1.</span> <span class="toc-text">关于页面跳转的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于页面数据传递的实现"><span class="toc-number">4.2.</span> <span class="toc-text">关于页面数据传递的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于数据请求接口name字段的处理"><span class="toc-number">4.3.</span> <span class="toc-text">关于数据请求接口name字段的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars1.githubusercontent.com/u/23609695?s=400&amp;u=d2db8f6efdee5add420addf7f89b916f7ef47ca7&amp;v=4"></div><div class="author-info__name text-center">Rao Jinwei</div><div class="author-info__description text-center">追寻生活的影子</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pic1.win4000.com/wallpaper/7/59bb35a6c903f.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Rao Jinwei's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">运用react-navigation重构项目总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/重构/">重构</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，完成了公司项目的底层代码重构，主要内容是采用新的导航器—<strong>react-navigation</strong>，来取代之前用的react官方提供的页面导航器<strong>Navigator</strong>。重构期间，不是很顺利，踩了不少坑，毕竟是底层的代码，所以重构起来非常谨慎，怕影响到上层的业务逻辑。大部分的重构都是由我一个人负责完成，做了不少笔记，刚好我的个人博客撘好了，那就在这里总结一下重构过程吧。</p>
<a id="more"></a>
<h2 id="Question：为什么要重构？"><a href="#Question：为什么要重构？" class="headerlink" title="Question：为什么要重构？"></a>Question：为什么要重构？</h2><p>首先，重构不是老大要求的，而是我提出来的并得到允许才进行的。为什么我要提出要抛弃Navigator？有几点：</p>
<blockquote>
<ul>
<li>react-native官方提供的页面导航器组件Navigator性能非常不好，这点官方也承认了，在react-native<strong>0.44</strong>版本之后已经删掉了这个组件，并推荐使用第三方组件<strong>react-navigation</strong>。</li>
<li>在我用Navigator实际项目开发中，就感觉到了它的不友好，性能非常差。特别是开启Chrome远程调试的时候，在页面跳转中会导致整个程序的卡死，崩溃，所以我只能用Android Studio来看debug，然而Android Studio查看JSON数据很是蛋疼，不能像Chrome那样可以格式化JSON，所以非常影响我的开发效率。</li>
<li>react-navigation就是为了解决这个问题而生的，据称性能非常接近原生，我写了几个demo发现确实解决了我之前遇到的问题。</li>
<li>既然官方已经宣布不再维护Navigator，如果项目在往后要升级react-native版本，那就必须放弃Navigator这个组件。</li>
</ul>
</blockquote>
<h2 id="重构前的准备"><a href="#重构前的准备" class="headerlink" title="重构前的准备"></a>重构前的准备</h2><p>大家都知道，想要重构底层的代码，就首先要把项目结构弄得非常熟悉，尽量不要影响上层的业务代码，不然bug多得修到你想吐=。=</p>
<p>（本来想用七牛云图床来展示分析导图的，但是注册七牛云要绑定域名，域名购买还是审核实名制，总之今天是用不了图床的了orz…）<br>算了，就用文字 + 代码来说说吧…</p>
<p><img src="/images/G1.png" alt="&quot;基本逻辑&quot;">  </p>
<p>之前的项目整个页面跳转都是通过Navigator来维护的，所有的页面跳转和通讯通过AppService类提供的静态方法进行，再细点页面跳转和数据传递都是使用<code>AppService.forward</code>这个方法实现。其中，<br><code>AppService.forward(Route)</code>，这个方法会接收<code>Route</code>对象，这个对象的结构是<code>{name:&#39;&#39;,dest:&#39;&#39;,param:{}}</code>,<code>name</code>是获取的数据的接口名,<code>dest</code>是页面名,<code>param</code>是传递的参数。</p>
<pre><code>页面A--(to)---&gt;Navigator[AppService.forward(Route)]--(to)---&gt;页面B
</code></pre><h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>弄清了项目的设计结构，就要开始着手替换<code>Navigator</code>的计划了。首先，我要做到的就是要用最小的成本来实现组件的替换。当前项目的页面结构分为多个模块，每个模块下又具分为多个子页面，都是<code>模块名_页面具名.js</code>。在<code>app.js</code>,也就是根文件下，会全局注册模块页面，然后通过<code>AppService.forward(页面具名)</code>来进行跳转，这就是Navigator的实现方式。我只有<strong>用react-navigation实现页面跳转的方法和Navigator实现方法一致</strong>，才能最大程度的减少项目的重构成本，毕竟在外层的代码有太多太多是用到<code>Appservice.forward(Route)</code>这个方法了。</p>
<h3 id="关于页面跳转的实现"><a href="#关于页面跳转的实现" class="headerlink" title="关于页面跳转的实现"></a>关于页面跳转的实现</h3><p><code>react-navigation</code>提供的页面跳转方法只要是通过<code>StackNavigator</code>这个api来实现的:<br></p>
<p><code>StackNavigator(RouteConfigs, StackNavigatorConfig)</code><br><br><strong>下面只给出demo</strong></p>
<pre><code>const Navs = StackNavigator({
    页面名:{screen: (页面.js)},
    页面名:{screen: (页面.js)},
    页面名:{screen: (页面.js)},
    ...
},{
    编写基本配置...
    如跳转动画选择，
    导航栏显示方式，
    还有页面回调等等
})

跳转就是使用
this.props.navigation.navigate(&apos;页面名&apos;,{参数})来实现
</code></pre><p><img src="/images/G2.png" alt="&quot;基本逻辑&quot;"></p>
<p>我在<code>app.js</code>里面全局注册StackNavigator, 并改写了一个<code>function</code>来格式化装有<strong>页面名.js</strong>对象的数据格式，让这个对象的数据结构为<code>{页面名:{screen: (页面名.js)},...}</code>(这是<code>react-navigation</code>规定的)，初始化页面默认为<strong>start.js(登录页)</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式化成&#123;wd.home:&#123;screen:wd.home&#125;&#125;</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPages</span>(<span class="params">pages</span>) </span>&#123;</div><div class="line">	<span class="comment">// pages是一个包含所有项目页面引用的对象</span></div><div class="line">	<span class="keyword">const</span> allPages = &#123;&#125;;</div><div class="line">	<span class="keyword">let</span> obj = &#123;&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> pages)&#123;</div><div class="line">		obj = &#123;<span class="attr">screen</span>: pages[key]&#125;;</div><div class="line">		allPages[<span class="string">`<span class="subst">$&#123;key&#125;</span>`</span>] = obj</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> allPages</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> screenPages = initPages(AppService.pages);</div><div class="line"></div><div class="line"><span class="keyword">const</span> Navs = StackNavigator(</div><div class="line">    &#123;</div><div class="line">	start:&#123;<span class="attr">screen</span>:start&#125;,</div><div class="line">	...screenPages</div><div class="line">    &#125;, </div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="关于页面数据传递的实现"><a href="#关于页面数据传递的实现" class="headerlink" title="关于页面数据传递的实现"></a>关于页面数据传递的实现</h3><p>完成了页面跳转，接下来就要实现页面之间的数据了。</p>
<p>在使用Navigator的时候，数据都存放在<code>Route.param</code>对象里面，然后在跳转目标页面里面通过<code>this.props.route.param</code>来获取传来的数据。</p>
<p>在react-navigation中，数据是通过props.navigation.navigate这个api来进行传递的，比如：</p>
<pre><code>页面A---&gt;this.props.navigation.navigate(&apos;页面B&apos;，{参数})---&gt;页面B

在页面B内可以通过this.props.navigation.state.params来接收参数
</code></pre><p>现在，我就按照这种思路，重写了<code>AppService.forward()</code>这个函数，还有在<code>BasePage.js（ps:用于页面继承的类）</code>也做了大量修改。页面的跳转和数据传递，还是通过<code>AppService.forward(Route)</code>这种形式来传，<code>Route</code>对象的数据结构保持不变，一切的逻辑都在底层的AppService这个类里面进行重写和改造，分点实现是这样的:</p>
<blockquote>
<ul>
<li>props.route 替换为 props.navigation.state.params</li>
<li>this.props.route.param替换为this.props.navigation.state.params.param</li>
</ul>
</blockquote>
<p>现在，在页面B是通过<code>this.props.navigation.state.params.param</code>来获取参数，这样，基本实现了从最底层无缝地用react-navigation替换掉Navigator。</p>
<h3 id="关于数据请求接口name字段的处理"><a href="#关于数据请求接口name字段的处理" class="headerlink" title="关于数据请求接口name字段的处理"></a>关于数据请求接口name字段的处理</h3><p>在页面跳转过程中，如果<code>Appservice.forward(Route)</code>中<code>Route</code>里面有<code>name</code>字段，跳转的目标页面会根据这个接口<code>name</code>来请求数据，所以，我在AppService类中同样做了处理,基本是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 优先处理name字段</span></div><div class="line"><span class="keyword">const</span> param = &#123;&#125;;</div><div class="line">Route.name ? param加入name字段 : param加入dest和param字段</div><div class="line">AppService.forward(<span class="string">'页面名'</span>,param);</div><div class="line"></div><div class="line"><span class="comment">// 注意，这里AppService.forward已经被我封装好了，相当于</span></div><div class="line">AppService.forward == <span class="keyword">this</span>.props.navigation.navigate</div></pre></td></tr></table></figure>
<p>当然，具体的代码还是有很多业务逻辑判断来进行处理的，加上额外的组件有一些方法也需要进行重写，上面只是简单地说明了name的处理方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在公司的新项目中，这套react-natvigation方案已经开始使用，解决了chrome调试崩溃的问题，大大提高了开发效率。说真的，项目重构学到的知识还是很多的，比如，重构的过程中，我对react的使用有了更深的了解，在项目重构前，我做了不少关于react-navigation的demo，查阅了有关react-navigation的<a href="https://reactnavigation.org/docs/intro/" target="_blank" rel="external">文档</a>，还有<a href="http://blog.csdn.net/sinat_17775997/article/details/70176688" target="_blank" rel="external">博客</a>。对react-navigation的使用也越加熟悉。其实重构要做的不仅仅上面说的这些，还是有些耦合度有点高的组件，得一个个解耦，只有真正做到最大程度组件间的解耦，才能更好地维护项目代码。如何去降低代码之间的耦合度，也是一个非常值得探索的方向。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rao Jinwei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://shooterblog.site/2017/11/26/运用react-navigation重构项目总结/">http://shooterblog.site/2017/11/26/运用react-navigation重构项目总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明来自 <a href="http://shooterblog.site" target="_blank">Rao Jinwei's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/重构/">重构</a><a class="post-meta__tags" href="/tags/react/">react</a></div><elif theme.sharejs && theme.sharejs.enable></elif></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/11/27/webpack 3.X 学习笔记(一)/"><i class="fa fa-chevron-left">  </i><span>webpack 3.X 学习笔记(一)</span></a></div><div class="next-post pull-right"><a href="/2017/11/20/div垂直水平居中的N种方法/"><span>div垂直水平居中的N种方法</span><i class="fa fa-chevron-right"></i></a></div></nav><elif theme.laibili && theme.laibili.enable></elif><elif theme.gitment && theme.gitment.enable></elif><elif theme.gitalk && theme.gitalk.enable></elif></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Rao Jinwei</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.4.2"></script><script src="/js/fancybox.js?version=1.4.2"></script><script src="/js/sidebar.js?version=1.4.2"></script><script src="/js/copy.js?version=1.4.2"></script><script src="/js/fireworks.js?version=1.4.2"></script><script src="/js/transition.js?version=1.4.2"></script><script src="/js/scroll.js?version=1.4.2"></script><script src="/js/head.js?version=1.4.2"></script></body></html>